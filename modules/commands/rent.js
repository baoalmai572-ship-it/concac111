// ##### MODULE CORE #####
const fs = require('fs-extra');
const path = require('path');
const moment = require('moment-timezone');
const crypto = require('crypto');
const cron = require('node-cron');

// ##### C·∫§U H√åNH THU√ä BOT #####
const TIMEZONE = 'Asia/Ho_Chi_Minh';

// ##### PATHS & DIRECTORIES #####
const DATA_DIR = path.join(__dirname, 'cache', 'data_rentbot_pro');
const RENT_DATA_PATH = path.join(DATA_DIR, 'thuebot_pro.json');
const RENT_KEY_PATH = path.join(DATA_DIR, 'keys_pro.json');

// ƒê·∫£m b·∫£o th∆∞ m·ª•c data t·ªìn t·∫°i
fs.ensureDirSync(DATA_DIR);

module.exports.config = {
    name: 'rent',
    version: '13.3.0-fix-add',
    hasPermssion: 0,
    credits: 'Pcoder & Gemini',
    description: "H·ªá th·ªëng thu√™ bot ch·ªâ s·ª≠ d·ª•ng vƒÉn b·∫£n.",
    commandCategory: "System",
    usages: '[info | usekey | list | add | del | newkey | check | delkey]',
    cooldowns: 5,
};

// --- H√ÄM TI·ªÜN √çCH ---
function safeReadJSON(file, defaultValue) { try { if (!fs.existsSync(file)) return defaultValue; return JSON.parse(fs.readFileSync(file, 'utf8')); } catch { return defaultValue; } }
function safeWriteJSON(file, data) { try { fs.ensureDirSync(path.dirname(file)); fs.writeFileSync(file, JSON.stringify(data, null, 4), 'utf8'); } catch (e) { console.error(`[RENT] L·ªói ghi file JSON: ${file}`, e); } }
function hsdText(endDateStr, fullFormat = false) { const now = moment().tz(TIMEZONE); const endDate = moment(endDateStr, 'DD/MM/YYYY').endOf('day'); const daysDiff = endDate.diff(now, 'days'); const formattedEndDate = endDate.format('DD/MM/YYYY'); if (daysDiff >= 0) return `c√≤n ${daysDiff + 1} ng√†y${fullFormat ? ` (ƒë·∫øn ${formattedEndDate})` : ''}`; return `ƒë√£ h·∫øt h·∫°n ${Math.abs(daysDiff)} ng√†y${fullFormat ? ` (t·ª´ ${formattedEndDate})` : ''}`; }

async function changeBotNicknameInGroup(api, threadID, time_end) {
    try {
        const botID = api.getCurrentUserID();
        const now = moment().tz(TIMEZONE);
        const endDate = moment(time_end, 'DD/MM/YYYY').endOf('day');
        const daysDiff = endDate.diff(now, 'days');
        let nickname = (daysDiff >= 0) ? `[ ${daysDiff} days ] SCORING BOT` : `[ H·∫øt h·∫°n ] Bot thu√™`;
        await api.changeNickname(nickname, threadID, botID);
    } catch (e) {
        // B·ªè qua l·ªói
    }
}

module.exports.onLoad = async function ({ api }) {
    cron.schedule('5 0 * * *', async () => {
        const rentData = safeReadJSON(RENT_DATA_PATH, []);
        console.log('[RENT] B·∫Øt ƒë·∫ßu qu√©t v√† c·∫≠p nh·∫≠t tr·∫°ng th√°i thu√™ bot...');
        for (const group of rentData) {
            await changeBotNicknameInGroup(api, group.t_id, group.time_end);
            await new Promise(resolve => setTimeout(resolve, 500));
        }
        console.log('[RENT] Qu√©t xong.');
    }, { timezone: TIMEZONE });
};

module.exports.run = async function({ api, event, args, Users, Threads }) {
    const { threadID, senderID, messageID } = event;
    
    let rentData = safeReadJSON(RENT_DATA_PATH, []);
    let keyData = safeReadJSON(RENT_KEY_PATH, {});
    const saveData = () => safeWriteJSON(RENT_DATA_PATH, rentData);
    const saveKeys = () => safeWriteJSON(RENT_KEY_PATH, keyData);

    const command = args[0] ? args[0].toLowerCase() : '';
    const prefix = global.config.PREFIX || "!";
    
    const isAdmin = [...(global.config.ADMINBOT || []), ...(global.config.NDH || [])].includes(senderID);
    const send = (msg, callback) => api.sendMessage(msg, threadID, callback, messageID);

    switch (command) {
        case 'info': {
            const rentInfo = rentData.find(e => e.t_id === threadID);
            if (!rentInfo) return send(`‚ùå Nh√≥m n√†y ch∆∞a thu√™ bot.`);
            
            const groupInfo = await Threads.getInfo(threadID);
            const groupName = groupInfo.threadName || groupInfo.name || "Nh√≥m n√†y";
            const userName = await Users.getNameUser(rentInfo.id);
            const index = rentData.findIndex(e => e.t_id === threadID) + 1;
            
            const msg = `üåü TH√îNG TIN THU√ä BOT üåü\n` +
                        `------------------------------------\n` +
                        `üë§ Ng∆∞·ªùi thu√™: ${userName}\n` +
                        `üè† Nh√≥m: ${groupName}\n` +
                        `‚ñ∂Ô∏è Ng√†y thu√™: ${rentInfo.time_start}\n` +
                        `‚óÄÔ∏è Ng√†y h·∫øt h·∫°n: ${rentInfo.time_end}\n` +
                        `‚è≥ T√¨nh tr·∫°ng: ${hsdText(rentInfo.time_end, true)}\n` +
                        `üîë Key: ${rentInfo.key || "Admin th√™m tr·ª±c ti·∫øp"}\n` +
                        `üî¢ STT: ${index}`;
            return send(msg);
        }
        case 'usekey': {
            const keyToUse = args[1]?.toLowerCase();
            if (!keyToUse || !keyData[keyToUse]) return send('‚ùå M√£ key kh√¥ng h·ª£p l·ªá!');
            if (keyData[keyToUse].used) return send(`‚ùå M√£ key n√†y ƒë√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng.`);
            if (rentData.some(e => e.t_id === threadID)) return send(`‚ùå Nh√≥m n√†y ƒë√£ thu√™ bot. D√πng l·ªánh "rent add" ƒë·ªÉ gia h·∫°n.`);
            
            const keyInfo = keyData[keyToUse];
            const time_start = moment.tz(TIMEZONE).format('DD/MM/YYYY');
            const time_end = moment.tz(TIMEZONE).add(keyInfo.days, 'days').format('DD/MM/YYYY');
            
            rentData.push({ t_id: threadID, id: senderID, time_start, time_end, key: keyToUse });
            keyData[keyToUse].used = true;
            keyData[keyToUse].groupId = threadID;
            
            saveData();
            saveKeys();
            
            await changeBotNicknameInGroup(api, threadID, time_end);
            return send(`‚úÖ Bot ƒë√£ ƒë∆∞·ª£c k√≠ch ho·∫°t th√†nh c√¥ng!\nH·∫°n s·ª≠ d·ª•ng: ${keyInfo.days} ng√†y (ƒë·∫øn ${time_end}).`);
        }

        case 'add': {
            if (!isAdmin) return send("‚ùå B·∫°n kh√¥ng c√≥ quy·ªÅn.");
            if (args.length < 2) return send(`S·ª≠ d·ª•ng: ${prefix}rent add <s·ªë_ng√†y> [ID_nh√≥m_t√πy_ch·ªçn]\n\nL·ªánh n√†y d√πng ƒë·ªÉ TH√äM M·ªöI ho·∫∑c GIA H·∫†N cho m·ªôt nh√≥m.`);
            
            const soNgayThue = parseInt(args[1], 10);
            const targetTID = args[2] || threadID;

            if (isNaN(soNgayThue) || soNgayThue <= 0) return send(`‚ùå S·ªë ng√†y kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p m·ªôt s·ªë d∆∞∆°ng.`);

            const groupIndex = rentData.findIndex(e => e.t_id === targetTID);
            let message = '';

            if (groupIndex !== -1) { // GIA H·∫†N
                const existingGroup = rentData[groupIndex];
                const oldEndDate = moment(existingGroup.time_end, 'DD/MM/YYYY').tz(TIMEZONE);
                const newEndDate = oldEndDate.add(soNgayThue, 'days').format('DD/MM/YYYY');
                existingGroup.time_end = newEndDate;
                
                rentData[groupIndex] = existingGroup;
                
                await changeBotNicknameInGroup(api, targetTID, newEndDate);
                const groupInfo = await Threads.getInfo(targetTID);
                const groupName = groupInfo.threadName || groupInfo.name || `ID: ${targetTID}`;
                
                message = `‚úÖ GIA H·∫†N th√†nh c√¥ng!\n` +
                          `------------------------------------\n` +
                          `üè† Nh√≥m: ${groupName}\n` +
                          `üóìÔ∏è S·ªë ng√†y gia h·∫°n: ${soNgayThue} ng√†y\n` +
                          `‚óÄÔ∏è Ng√†y h·∫øt h·∫°n m·ªõi: ${newEndDate}`;
            } 
            else { // TH√äM M·ªöI
                const time_start = moment.tz(TIMEZONE).format('DD/MM/YYYY');
                const endDateStr = moment.tz(TIMEZONE).add(soNgayThue, 'days').format('DD/MM/YYYY');
                
                rentData.push({ t_id: targetTID, id: senderID, time_start, time_end: endDateStr, key: "" });
                
                await changeBotNicknameInGroup(api, targetTID, endDateStr);
                const groupInfo = await Threads.getInfo(targetTID);
                const groupName = groupInfo.threadName || groupInfo.name || `ID: ${targetTID}`;
                
                message = `‚úÖ TH√äM M·ªöI nh√≥m thu√™ th√†nh c√¥ng!\n` +
                          `------------------------------------\n` +
                          `üè† Nh√≥m: ${groupName}\n` +
                          `üóìÔ∏è Th·ªùi h·∫°n: ${soNgayThue} ng√†y\n` +
                          `‚óÄÔ∏è Ng√†y h·∫øt h·∫°n: ${endDateStr}`;
            }
            
            saveData();
            return send(message);
        }

        case 'del': {
            if (!isAdmin) return send("‚ùå B·∫°n kh√¥ng c√≥ quy·ªÅn.");
            const identifier = args[1];
            if (!identifier) return send(`Sai c√∫ ph√°p: ${prefix}rent del <STT|GroupID>`);
            
            let itemIndex = !isNaN(parseInt(identifier)) ? parseInt(identifier) - 1 : rentData.findIndex(e => e.t_id === identifier);
            if (itemIndex < 0 || itemIndex >= rentData.length) return send("‚ùå Kh√¥ng t√¨m th·∫•y nh√≥m.");
            
            const removedItem = rentData.splice(itemIndex, 1);
            saveData();
            
            return send(`üóëÔ∏è ƒê√£ x√≥a th√†nh c√¥ng nh√≥m c√≥ ID: ${removedItem[0].t_id}.`);
        }
        
        case 'list': {
            if (!isAdmin) return send("‚ùå B·∫°n kh√¥ng c√≥ quy·ªÅn.");
            if (rentData.length === 0) return send('Ch∆∞a c√≥ nh√≥m n√†o ƒëang thu√™ bot!');

            await send("ƒêang x·ª≠ l√Ω v√† l·∫•y t√™n c√°c nh√≥m, vui l√≤ng ƒë·ª£i...");

            const promises = rentData.map((item, index) => {
                return Threads.getInfo(item.t_id)
                    .then(groupInfo => {
                        const groupName = groupInfo.threadName || groupInfo.name || `ID: ${item.t_id}`;
                        return `${index + 1}. ${groupName}\n   - ID: ${item.t_id}\n   - HSD: ${item.time_end} (${hsdText(item.time_end)})`;
                    })
                    .catch(() => {
                        return `${index + 1}. ID: ${item.t_id} (‚ö†Ô∏è L·ªói/Bot ƒë√£ r·ªùi)\n   - HSD: ${item.time_end} (${hsdText(item.time_end)})`;
                    });
            });

            const results = await Promise.all(promises);
            let msg = `üìù DANH S√ÅCH ${rentData.length} NH√ìM ƒêANG THU√ä üìù\nReply tin nh·∫Øn n√†y v·ªõi "del <STT>"\n\n`;
            msg += results.join('\n\n');
            
            return send(msg, (err, info) => { 
                if (!err) global.client.handleReply.push({ name: this.config.name, messageID: info.messageID, author: senderID, rentalData: rentData }); 
            });
        }

        case 'newkey': {
            if (!isAdmin) return send("‚ùå B·∫°n kh√¥ng c√≥ quy·ªÅn.");
            const days = parseInt(args[1], 10);
            if (isNaN(days) || days <= 0) return send(`‚ùå S·ªë ng√†y kh√¥ng h·ª£p l·ªá.`);
            
            const generatedKey = `key_${crypto.randomBytes(4).toString('hex')}`;
            keyData[generatedKey] = { days: days, used: false, groupId: null };
            saveKeys();
            
            return send(`üîë ƒê√£ t·∫°o key m·ªõi: ${generatedKey}\nTh·ªùi h·∫°n: ${days} ng√†y`);
        }
        case 'check': {
            if (!isAdmin) return send("‚ùå B·∫°n kh√¥ng c√≥ quy·ªÅn.");
            if (Object.keys(keyData).length === 0) return send('Kh√¥ng c√≥ key n√†o trong h·ªá th·ªëng!');
            
            let msg = `üîë DANH S√ÅCH KEY üîë\n\n`;
            for (const [key, info] of Object.entries(keyData)) {
                msg += `> Key: ${key}\n - H·∫°n: ${info.days} ng√†y\n - Status: ${info.used ? `‚úÖ ƒê√£ d√πng (Nh√≥m: ${info.groupId || 'N/A'})` : '‚è≥ Ch∆∞a d√πng'}\n\n`;
            }
            return send(msg.trim());
        }
        case 'delkey': {
            if (!isAdmin) return send("‚ùå B·∫°n kh√¥ng c√≥ quy·ªÅn.");
            const keyToDelete = args[1]?.toLowerCase();
            if (!keyToDelete || !keyData[keyToDelete]) return send(`‚ùå Key kh√¥ng t·ªìn t·∫°i!`);
            
            delete keyData[keyToDelete];
            saveKeys();
            
            return send(`üóëÔ∏è ƒê√£ x√≥a key "${keyToDelete}".`);
        }
        default: {
            const commands = [
                { cmd: "info", desc: "Xem th√¥ng tin thu√™ c·ªßa nh√≥m hi·ªán t·∫°i." },
                { cmd: "usekey <M√£_Key>", desc: "K√≠ch ho·∫°t thu√™ bot b·∫±ng key." },
                { cmd: "list", desc: "Xem danh s√°ch c√°c nh√≥m thu√™ (admin)." },
                { cmd: "add <s·ªë_ng√†y> [id_nh√≥m]", desc: "Th√™m m·ªõi ho·∫∑c gia h·∫°n nh√≥m thu√™ (admin)." },
                { cmd: "del <STT|GroupID>", desc: "X√≥a nh√≥m kh·ªèi danh s√°ch thu√™ (admin)." },
                { cmd: "newkey <s·ªë_ng√†y>", desc: "T·∫°o key m·ªõi (admin)." },
                { cmd: "check", desc: "Ki·ªÉm tra t·∫•t c·∫£ c√°c key (admin)." },
                { cmd: "delkey <T√™n_Key>", desc: "X√≥a m·ªôt key (admin)." }
            ];
            let msg = "üåü MENU QU·∫¢N L√ù THU√ä BOT üåü\n\n";
            commands.forEach(c => {
                msg += `¬ª ${prefix}${this.config.name} ${c.cmd}\n   - ${c.desc}\n\n`;
            });
            return send(msg.trim());
        }
    }
};

module.exports.handleReply = async function({ api, event, handleReply }) {
    const { senderID, threadID, body } = event;
    const isAdmin = [...(global.config.ADMINBOT || []), ...(global.config.NDH || [])].includes(senderID);

    if (senderID !== handleReply.author || !isAdmin) return;
    
    let rentData = safeReadJSON(RENT_DATA_PATH, []);
    const saveData = () => safeWriteJSON(RENT_DATA_PATH, rentData);
    
    const { rentalData } = handleReply;
    const [command, stt] = body.split(" ");
    
    if (command.toLowerCase() !== 'del' || !stt || isNaN(parseInt(stt))) return;
    
    const index = parseInt(stt) - 1;
    if (index < 0 || index >= rentalData.length) return api.sendMessage("‚ùå STT kh√¥ng h·ª£p l·ªá.", threadID);
    
    const targetGroupTID = rentalData[index].t_id;
    const globalIndex = rentData.findIndex(e => e.t_id === targetGroupTID);
    
    if (globalIndex === -1) return api.sendMessage("‚ùå Nh√≥m n√†y c√≥ th·ªÉ ƒë√£ b·ªã x√≥a.", threadID);
    
    rentData.splice(globalIndex, 1); 
    saveData();
    return api.sendMessage(`üóëÔ∏è ƒê√£ x√≥a th√†nh c√¥ng nh√≥m STT ${stt} (ID: ${targetGroupTID}).`, threadID);
};
